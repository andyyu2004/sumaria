#lang racket #| â˜… CSC324 Fall 2019: Exercise 8 â˜… |#
#|
Module: ex8
Description: Exercise 8: Representing Evaluation Order
Copyright: (c) University of Toronto
               CSC324 Principles of Programming Languages, Fall 2019

Before starting, please review the exercise guidelines at
<https://www.cs.toronto.edu/~david/csc324/homework.html>.
|#
(provide single-assignment-form condensed-single-assignment-form)

;-------------------------------------------------------------------------------
; â˜… Task 1: Single assignment form â˜…
;-------------------------------------------------------------------------------
#|
(single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *single assignment form* of the given expression.
  In Racket, this will be a list of name bindings of the form
  '((define _v0 ___)
    (define _v1 ___)
    (define _v2 ___)
    ...
    (define _vn ___))

  where _vn is bound to the value of the entire expression.

 Technical hints:
 1. If you want to use an accumulator that stores more than one type of value,
    you can either create your own struct or just use a list.
 2. You can use either `~a` or `format` to generate the identifier names as strings,
    and then `string->symbol` to convert them into symbols.
 3. A good starting point is to define a main recursive helper that takes both
    and <expr> and a list of bindings (this is the "accumulator" parameter).
|#

; map-pair :: (a -> ([b], a)) -> [a] -> ([b], [a])
; (Expr -> State [Binding] Expr) -> [Expr] -> State [Binding] [Expr]
(define/match (map-pair f bindings xs)
  [(_ _ (list)) bindings . (list)]
  [(_ _ (cons x xs))
   (let ([pair (f bindings x)])
     (cons (cons (append bindings (list (car pair))) (cdr pair)) (map-pair f bindings xs)))])
  
  
(define (single-assignment-form expr)
  (car (h-m (list) expr)))

; bind-name :: [binding] -> expr -> ([binding], expr)
(define (bind-name bindings expr)
  (let* ([newname (string->symbol(format "_v~a" (length bindings)))]
         [newbindings (append bindings (list (list 'define newname expr)))])
    (cons newbindings newname)))

; [(b, a)] -> ([b], [a])
(define/match (split xs)
  [((list)) (cons (list) (list))]
  [((cons x xs))
   (let ([pairs (split xs)])
     (cons (cons (car x) (car pairs)) (cons (cdr x) (cdr pairs))))])

#; (define (mapM f) (lambda (xs) (sequence (map f xs))))

; sequence :: [([b], a)] -> ([b], [a])
#; (define/match (sequence xs)
     [((list)) (cons () )])

; bind-names :: [Binding] -> [Expr] -> ([Binding], [Expr])
(define/match (bind-names bindings exprs)
  [(_ (list)) (cons bindings (list))]
  [(_ (cons x xs))
   (let* ([pair (bind-name bindings x)]
          [pairs (bind-names (car pair) xs)])
     (cons (car pairs) (cons (cdr pair) (cdr pairs))))])

(define (mapm f)
  (lambda (bindings exprs)
    (match exprs
      [(list) (cons bindings (list))]
      [(cons x xs)
       (let* ([pair (f bindings x)]
              [pairs ((mapm f) (car pair) xs)])
         (cons (car pairs) (cons (cdr pair) (cdr pairs))))])))

; h-m :: [Binding] -> Expr -> ([Binding], Expr)
(define/match (h-m bindings expr)
  [(_ (? number?)) (bind-name bindings expr)]
  [(_ (? symbol?)) (bind-name bindings expr)]
  [(_ (cons f args))
   (let* ([fpair (bind-name bindings f)]
          [arg-pairs ((mapm h-m) (car fpair) args)])
     (bind-name (car arg-pairs) (cons (cdr fpair) (cdr arg-pairs))))])


; [Binding] -> [Expr] -> ([Binding], [Expr])
(define/match (h-m-mapM bindings exprs)
  [(_ (list)) (cons bindings (list))]
  [(_ (cons x xs))
   (let* ([pair (h-m bindings x)]
          [pairs (h-m-mapM (car pair) xs)])
     (cons (car pairs) (cons (cdr pair) (cdr pairs))))])

(define expr-with-dups '(* (+ x x) (+ y y)))
  
(module+ test
  (require rackunit)

  (test-equal? "Numeric literal"
               (single-assignment-form 5)
               '((define _v0 5)))

  (test-equal? "Identifier"
               (single-assignment-form 'x)
               '((define _v0 x)))

  (test-equal? "First example from handout"
               (single-assignment-form '(* 2 3 x))
               '((define _v0 *)
                 (define _v1 2)
                 (define _v2 3)
                 (define _v3 x)
                 (define _v4 (_v0 _v1 _v2 _v3))))

  (test-equal? "Second example from handout"
               (single-assignment-form '(+ (* 2 3) (* 6 7)))
               '((define _v0 +)
                 (define _v1 *)
                 (define _v2 2)
                 (define _v3 3)
                 (define _v4 (_v1 _v2 _v3))
                 (define _v5 *)
                 (define _v6 6)
                 (define _v7 7)
                 (define _v8 (_v5 _v6 _v7))
                 (define _v9 (_v0 _v4 _v8)))))


;-------------------------------------------------------------------------------
; â˜… Task 2: Condensed Single Assignment Form â˜…
;-------------------------------------------------------------------------------
#|
(condensed-single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *condensed single assignment form* of the given expression.
  *We will not test this function on an <expr> that is atomic (number/identifier).*
  You may freely choose how to handle this case, which may depend on the rest of
  your implementation.
|#
(define (condensed-single-assignment-form expr)
  (car (h-m-c (list) expr)))

(define/match (h-m-c bindings expr)
  [(_ (? number?)) (cons bindings expr)]
  [(_ (? symbol?)) (cons bindings expr)]
  [(_ (cons f args))
   (let* ([arg-pairs ((mapm h-m-c) bindings args)])
     (bind-name (car arg-pairs) (cons f (cdr arg-pairs))))])

(module+ test
    (test-equal? "First example from handout c"
                 (condensed-single-assignment-form '(* 2 3 x))
                 '((define _v0 (* 2 3 x))))

    (test-equal? "Second example from handout c"
                 (condensed-single-assignment-form '(+ (* 2 3) (* 6 7)))
                 '((define _v0 (* 2 3))
                   (define _v1 (* 6 7))
                   (define _v2 (+ _v0 _v1)))))