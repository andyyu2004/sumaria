#lang racket #| â˜… CSC324 Fall 2019: Exercise 8 â˜… |#
#|
Module: ex8
Description: Exercise 8: Representing Evaluation Order
Copyright: (c) University of Toronto
               CSC324 Principles of Programming Languages, Fall 2019

Before starting, please review the exercise guidelines at
<https://www.cs.toronto.edu/~david/csc324/homework.html>.
|#
(provide single-assignment-form condensed-single-assignment-form)

;-------------------------------------------------------------------------------
; â˜… Task 1: Single assignment form â˜…
;-------------------------------------------------------------------------------
#|
(single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *single assignment form* of the given expression.
  In Racket, this will be a list of name bindings of the form
  '((define _v0 ___)
    (define _v1 ___)
    (define _v2 ___)
    ...
    (define _vn ___))

  where _vn is bound to the value of the entire expression.

 Technical hints:
 1. If you want to use an accumulator that stores more than one type of value,
    you can either create your own struct or just use a list.
 2. You can use either `~a` or `format` to generate the identifier names as strings,
    and then `string->symbol` to convert them into symbols.
 3. A good starting point is to define a main recursive helper that takes both
    and <expr> and a list of bindings (this is the "accumulator" parameter).
|#
(define (single-assignment-form expr)
  (foldl helper (list) (sub-expressions expr)))

(define/match (sub-expressions expr)
  [((? number?)) (list expr)]
  [((? symbol?)) (list expr)]
  [((list f args ...)) (append (cons f (append-map sub-expressions args)) (list expr))])

#| [Binding] -> name -> expr |#
(define/match (find-binding-expr bindings id)
  [((list) _) id] ; return the id as default if no binding for it is found
  [((cons (list 'define name expr) xs) _)
   (if (equal? name id)
       expr
       (find-binding-expr xs id))])
  
(define/match (expand bindings expr)
  [(_ (? number?)) expr]
  [(_ (? symbol?))
   (let ([newexpr (find-binding-expr bindings expr)])
     (if (equal? expr newexpr)
         newexpr
         (expand bindings newexpr)))]
  [(_ (list f args ...)) (cons (expand bindings f) (map (lambda (x) (expand bindings x)) args))])

; return the name of the binding that has value of expression by searching the bindings starting at index (i - 1)
; return the param 'expr' by default if nothing is found
(define (name-of-binding bindings i expr)
  (if (<= i 0)
      expr
      (match (list-ref bindings (- i 1))
        [(list 'define name expression)
         (if (equal? (expand bindings expr) (expand bindings expression))
             name
             (name-of-binding bindings (- i 1) expr))])))
                         
(define/match (helper expr bindings)
  [((? number?) _) (append bindings (list (list 'define (string->symbol (format "_v~a" (length bindings))) expr)))]
  [((? symbol?) _) (append bindings (list (list 'define (string->symbol (format "_v~a" (length bindings))) expr)))]
  [((list f args ...) _)
   (append bindings (list
                     (list 'define (string->symbol (format "_v~a" (length bindings)))
                           (cons (name-of-binding bindings (length bindings) f)
                                 (map (lambda (x) (name-of-binding bindings (length bindings) x)) args)))))])


(module+ test
  (require rackunit)

  (test-equal? "Full Expansion"
               (let ([bindings '((define _v0 +)
                                 (define _v1 *)
                                 (define _v2 2)
                                 (define _v3 3)
                                 (define _v4 (_v1 _v2 _v3))
                                 (define _v5 *)
                                 (define _v6 6)
                                 (define _v7 7)
                                 (define _v8 (_v5 _v6 _v7))
                                 (define _v9 (_v0 _v4 _v8)))])
                 (expand bindings '(_v0 _v4 _v8)))
               '(+ (* 2 3) (* 6 7)))
                
  (test-equal? "Numeric literal"
               (single-assignment-form 5)
               '((define _v0 5)))

  (test-equal? "Identifier"
               (single-assignment-form 'x)
               '((define _v0 x)))

  (test-equal? "First example from handout"
               (single-assignment-form '(* 2 3 x))
               '((define _v0 *)
                 (define _v1 2)
                 (define _v2 3)
                 (define _v3 x)
                 (define _v4 (_v0 _v1 _v2 _v3))))

  (test-equal? "Second example from handout"
               (single-assignment-form '(+ (* 2 3) (* 6 7)))
               '((define _v0 +)
                 (define _v1 *)
                 (define _v2 2)
                 (define _v3 3)
                 (define _v4 (_v1 _v2 _v3))
                 (define _v5 *)
                 (define _v6 6)
                 (define _v7 7)
                 (define _v8 (_v5 _v6 _v7))
                 (define _v9 (_v0 _v4 _v8)))))


;-------------------------------------------------------------------------------
; â˜… Task 2: Condensed Single Assignment Form â˜…
;-------------------------------------------------------------------------------
#|
(condensed-single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *condensed single assignment form* of the given expression.
  *We will not test this function on an <expr> that is atomic (number/identifier).*
  You may freely choose how to handle this case, which may depend on the rest of
  your implementation.
|#
(define (condensed-single-assignment-form expr)
  (foldl c-helper (list) (function-calls expr)))

(define/match (c-helper expr bindings)
  [((cons f args) _)
   (append bindings (list
           (list 'define (string->symbol (format "_v~a" (length bindings)))
                 (cons (name-of-binding bindings (length bindings) f)
                       (map (lambda (x) (name-of-binding bindings (length bindings) x)) args)))))])
  
  
(define/match (function-calls expr)
  [((cons f args)) (append (append-map function-calls args) (list expr))]
  [(_) (list)])

(module+ test
    (test-equal? "First example from handout"
                 (condensed-single-assignment-form '(* 2 3 x))
                 '((define _v0 (* 2 3 x))))

    (test-equal? "Second example from handout"
                 (condensed-single-assignment-form '(+ (* 2 3) (* 6 7)))
                 '((define _v0 (* 2 3))
                   (define _v1 (* 6 7))
                   (define _v2 (+ _v0 _v1)))))




















